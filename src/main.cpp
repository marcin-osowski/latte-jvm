/*** Compiler Front-End Test automatically generated by the BNF Converter ***/
/*                                                                          */
/* This test will parse a file, print the abstract syntax tree, and then    */
/* pretty-print the result.                                                 */
/*                                                                          */
/****************************************************************************/
#include <stdio.h>
#include <iostream>
#include "parser/Parser.H"
#include "parser/Printer.H"
#include "parser/Absyn.H"
#include "functions_types.h"
#include "type_check.h"
#include "return_check.h"
#include "environment.h"

int main(int argc, char ** argv)
{
    FILE *input;
    if (argc > 1) {
        input = fopen(argv[1], "r");
        if (!input) {
            fprintf(stderr, "Error opening input file.\n");
            exit(1);
        }
    }else {
        input = stdin;
    }
    /* The default entry point is used. For other options see Parser.H */
    latte_parser::Program *parse_tree = latte_parser::pProgram(input);
    if (!parse_tree) {
        return 1;
    }
    /*
    {
        // Pretty-print
        printf("\nParse Succesful!\n");
        printf("\n[Abstract Syntax]\n");
        latte_parser::ShowAbsyn s;
        printf("%s\n\n", s.show(parse_tree));
        printf("[Linearized Tree]\n");
        latte_parser::PrintAbsyn p;
        printf("%s\n\n", p.print(parse_tree));
    }*/
    /*
    {
        Environment<int> env;
        env.insert(std::string("a"), 5);
        {
            auto p = env.pusher();
            env.insert(std::string("a"), 7);
            env[std::string("a")] = 8;
            std::cout << env["a"] << "\n";
        }
        std::cout << env["a"] << "\n";
    }*/

    {
        /* Functions load */
        latte_type_check::FunTypesLoader functions_types;
        parse_tree->accept(&functions_types);
        if(! functions_types.getErrors().empty()){
            std::cerr << "ERROR\n";
            std::cout << functions_types.getErrors().toString();
            return 1;
        }

        //std::cout << "Loaded functions:\n";
        //std::cout << functions_types.getResultEnv().toString();

        /* Type check */
        latte_type_check::TypeCheck type_check(functions_types.getResultEnv());
        parse_tree->accept(&type_check);
        if(! type_check.getErrors().empty()){
            std::cerr << "ERROR\n";
            std::cout << type_check.getErrors().toString();
            return 1;
        }

        latte_type_check::ReturnCheck return_check(functions_types.getResultEnv());
        parse_tree->accept(&return_check);
        if(! return_check.getErrors().empty()){
            std::cerr << "ERROR\n";
            std::cout << return_check.getErrors().toString();
            return 1;
        }

        std::cout << "Type check OK\n";


    }

    return 0;
}


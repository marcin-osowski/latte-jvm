//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"
namespace latte_parser
{
/********************   PProg    ********************/
PProg::PProg(ListTopDef *p1)
{
  listtopdef_ = p1;

}

PProg::PProg(const PProg & other)
{
  listtopdef_ = other.listtopdef_->clone();

}

PProg &PProg::operator=(const PProg & other)
{
  PProg tmp(other);
  swap(tmp);
  return *this;
}

void PProg::swap(PProg & other)
{
  std::swap(listtopdef_, other.listtopdef_);

}

PProg::~PProg()
{
  delete(listtopdef_);

}

void PProg::accept(Visitor *v)
{
  v->visitPProg(this);
}

PProg *PProg::clone() const
{
  return new PProg(*this);
}



/********************   TFnDef    ********************/
TFnDef::TFnDef(Type *p1, Ident p2, ListArg *p3, Block *p4)
{
  type_ = p1;
  ident_ = p2;
  listarg_ = p3;
  block_ = p4;

}

TFnDef::TFnDef(const TFnDef & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;
  listarg_ = other.listarg_->clone();
  block_ = other.block_->clone();

}

TFnDef &TFnDef::operator=(const TFnDef & other)
{
  TFnDef tmp(other);
  swap(tmp);
  return *this;
}

void TFnDef::swap(TFnDef & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(listarg_, other.listarg_);
  std::swap(block_, other.block_);

}

TFnDef::~TFnDef()
{
  delete(type_);
  delete(listarg_);
  delete(block_);

}

void TFnDef::accept(Visitor *v)
{
  v->visitTFnDef(this);
}

TFnDef *TFnDef::clone() const
{
  return new TFnDef(*this);
}



/********************   AArg    ********************/
AArg::AArg(Type *p1, Ident p2)
{
  type_ = p1;
  ident_ = p2;

}

AArg::AArg(const AArg & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;

}

AArg &AArg::operator=(const AArg & other)
{
  AArg tmp(other);
  swap(tmp);
  return *this;
}

void AArg::swap(AArg & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

AArg::~AArg()
{
  delete(type_);

}

void AArg::accept(Visitor *v)
{
  v->visitAArg(this);
}

AArg *AArg::clone() const
{
  return new AArg(*this);
}



/********************   BBlock    ********************/
BBlock::BBlock(ListStmt *p1)
{
  liststmt_ = p1;

}

BBlock::BBlock(const BBlock & other)
{
  liststmt_ = other.liststmt_->clone();

}

BBlock &BBlock::operator=(const BBlock & other)
{
  BBlock tmp(other);
  swap(tmp);
  return *this;
}

void BBlock::swap(BBlock & other)
{
  std::swap(liststmt_, other.liststmt_);

}

BBlock::~BBlock()
{
  delete(liststmt_);

}

void BBlock::accept(Visitor *v)
{
  v->visitBBlock(this);
}

BBlock *BBlock::clone() const
{
  return new BBlock(*this);
}



/********************   SEmpty    ********************/
SEmpty::SEmpty()
{

}

SEmpty::SEmpty(const SEmpty & other)
{

}

SEmpty &SEmpty::operator=(const SEmpty & other)
{
  SEmpty tmp(other);
  swap(tmp);
  return *this;
}

void SEmpty::swap(SEmpty & other)
{

}

SEmpty::~SEmpty()
{

}

void SEmpty::accept(Visitor *v)
{
  v->visitSEmpty(this);
}

SEmpty *SEmpty::clone() const
{
  return new SEmpty(*this);
}



/********************   SBStmt    ********************/
SBStmt::SBStmt(Block *p1)
{
  block_ = p1;

}

SBStmt::SBStmt(const SBStmt & other)
{
  block_ = other.block_->clone();

}

SBStmt &SBStmt::operator=(const SBStmt & other)
{
  SBStmt tmp(other);
  swap(tmp);
  return *this;
}

void SBStmt::swap(SBStmt & other)
{
  std::swap(block_, other.block_);

}

SBStmt::~SBStmt()
{
  delete(block_);

}

void SBStmt::accept(Visitor *v)
{
  v->visitSBStmt(this);
}

SBStmt *SBStmt::clone() const
{
  return new SBStmt(*this);
}



/********************   SDecl    ********************/
SDecl::SDecl(Type *p1, ListItem *p2)
{
  type_ = p1;
  listitem_ = p2;

}

SDecl::SDecl(const SDecl & other)
{
  type_ = other.type_->clone();
  listitem_ = other.listitem_->clone();

}

SDecl &SDecl::operator=(const SDecl & other)
{
  SDecl tmp(other);
  swap(tmp);
  return *this;
}

void SDecl::swap(SDecl & other)
{
  std::swap(type_, other.type_);
  std::swap(listitem_, other.listitem_);

}

SDecl::~SDecl()
{
  delete(type_);
  delete(listitem_);

}

void SDecl::accept(Visitor *v)
{
  v->visitSDecl(this);
}

SDecl *SDecl::clone() const
{
  return new SDecl(*this);
}



/********************   SAss    ********************/
SAss::SAss(Ident p1, Expr *p2)
{
  ident_ = p1;
  expr_ = p2;

}

SAss::SAss(const SAss & other)
{
  ident_ = other.ident_;
  expr_ = other.expr_->clone();

}

SAss &SAss::operator=(const SAss & other)
{
  SAss tmp(other);
  swap(tmp);
  return *this;
}

void SAss::swap(SAss & other)
{
  std::swap(ident_, other.ident_);
  std::swap(expr_, other.expr_);

}

SAss::~SAss()
{
  delete(expr_);

}

void SAss::accept(Visitor *v)
{
  v->visitSAss(this);
}

SAss *SAss::clone() const
{
  return new SAss(*this);
}



/********************   SIncr    ********************/
SIncr::SIncr(Ident p1)
{
  ident_ = p1;

}

SIncr::SIncr(const SIncr & other)
{
  ident_ = other.ident_;

}

SIncr &SIncr::operator=(const SIncr & other)
{
  SIncr tmp(other);
  swap(tmp);
  return *this;
}

void SIncr::swap(SIncr & other)
{
  std::swap(ident_, other.ident_);

}

SIncr::~SIncr()
{

}

void SIncr::accept(Visitor *v)
{
  v->visitSIncr(this);
}

SIncr *SIncr::clone() const
{
  return new SIncr(*this);
}



/********************   SDecr    ********************/
SDecr::SDecr(Ident p1)
{
  ident_ = p1;

}

SDecr::SDecr(const SDecr & other)
{
  ident_ = other.ident_;

}

SDecr &SDecr::operator=(const SDecr & other)
{
  SDecr tmp(other);
  swap(tmp);
  return *this;
}

void SDecr::swap(SDecr & other)
{
  std::swap(ident_, other.ident_);

}

SDecr::~SDecr()
{

}

void SDecr::accept(Visitor *v)
{
  v->visitSDecr(this);
}

SDecr *SDecr::clone() const
{
  return new SDecr(*this);
}



/********************   SRet    ********************/
SRet::SRet(Expr *p1)
{
  expr_ = p1;

}

SRet::SRet(const SRet & other)
{
  expr_ = other.expr_->clone();

}

SRet &SRet::operator=(const SRet & other)
{
  SRet tmp(other);
  swap(tmp);
  return *this;
}

void SRet::swap(SRet & other)
{
  std::swap(expr_, other.expr_);

}

SRet::~SRet()
{
  delete(expr_);

}

void SRet::accept(Visitor *v)
{
  v->visitSRet(this);
}

SRet *SRet::clone() const
{
  return new SRet(*this);
}



/********************   SVRet    ********************/
SVRet::SVRet()
{

}

SVRet::SVRet(const SVRet & other)
{

}

SVRet &SVRet::operator=(const SVRet & other)
{
  SVRet tmp(other);
  swap(tmp);
  return *this;
}

void SVRet::swap(SVRet & other)
{

}

SVRet::~SVRet()
{

}

void SVRet::accept(Visitor *v)
{
  v->visitSVRet(this);
}

SVRet *SVRet::clone() const
{
  return new SVRet(*this);
}



/********************   SCond    ********************/
SCond::SCond(Expr *p1, Stmt *p2)
{
  expr_ = p1;
  stmt_ = p2;

}

SCond::SCond(const SCond & other)
{
  expr_ = other.expr_->clone();
  stmt_ = other.stmt_->clone();

}

SCond &SCond::operator=(const SCond & other)
{
  SCond tmp(other);
  swap(tmp);
  return *this;
}

void SCond::swap(SCond & other)
{
  std::swap(expr_, other.expr_);
  std::swap(stmt_, other.stmt_);

}

SCond::~SCond()
{
  delete(expr_);
  delete(stmt_);

}

void SCond::accept(Visitor *v)
{
  v->visitSCond(this);
}

SCond *SCond::clone() const
{
  return new SCond(*this);
}



/********************   SCondElse    ********************/
SCondElse::SCondElse(Expr *p1, Stmt *p2, Stmt *p3)
{
  expr_ = p1;
  stmt_1 = p2;
  stmt_2 = p3;

}

SCondElse::SCondElse(const SCondElse & other)
{
  expr_ = other.expr_->clone();
  stmt_1 = other.stmt_1->clone();
  stmt_2 = other.stmt_2->clone();

}

SCondElse &SCondElse::operator=(const SCondElse & other)
{
  SCondElse tmp(other);
  swap(tmp);
  return *this;
}

void SCondElse::swap(SCondElse & other)
{
  std::swap(expr_, other.expr_);
  std::swap(stmt_1, other.stmt_1);
  std::swap(stmt_2, other.stmt_2);

}

SCondElse::~SCondElse()
{
  delete(expr_);
  delete(stmt_1);
  delete(stmt_2);

}

void SCondElse::accept(Visitor *v)
{
  v->visitSCondElse(this);
}

SCondElse *SCondElse::clone() const
{
  return new SCondElse(*this);
}



/********************   SWhile    ********************/
SWhile::SWhile(Expr *p1, Stmt *p2)
{
  expr_ = p1;
  stmt_ = p2;

}

SWhile::SWhile(const SWhile & other)
{
  expr_ = other.expr_->clone();
  stmt_ = other.stmt_->clone();

}

SWhile &SWhile::operator=(const SWhile & other)
{
  SWhile tmp(other);
  swap(tmp);
  return *this;
}

void SWhile::swap(SWhile & other)
{
  std::swap(expr_, other.expr_);
  std::swap(stmt_, other.stmt_);

}

SWhile::~SWhile()
{
  delete(expr_);
  delete(stmt_);

}

void SWhile::accept(Visitor *v)
{
  v->visitSWhile(this);
}

SWhile *SWhile::clone() const
{
  return new SWhile(*this);
}



/********************   SSExp    ********************/
SSExp::SSExp(Expr *p1)
{
  expr_ = p1;

}

SSExp::SSExp(const SSExp & other)
{
  expr_ = other.expr_->clone();

}

SSExp &SSExp::operator=(const SSExp & other)
{
  SSExp tmp(other);
  swap(tmp);
  return *this;
}

void SSExp::swap(SSExp & other)
{
  std::swap(expr_, other.expr_);

}

SSExp::~SSExp()
{
  delete(expr_);

}

void SSExp::accept(Visitor *v)
{
  v->visitSSExp(this);
}

SSExp *SSExp::clone() const
{
  return new SSExp(*this);
}



/********************   INoInit    ********************/
INoInit::INoInit(Ident p1)
{
  ident_ = p1;

}

INoInit::INoInit(const INoInit & other)
{
  ident_ = other.ident_;

}

INoInit &INoInit::operator=(const INoInit & other)
{
  INoInit tmp(other);
  swap(tmp);
  return *this;
}

void INoInit::swap(INoInit & other)
{
  std::swap(ident_, other.ident_);

}

INoInit::~INoInit()
{

}

void INoInit::accept(Visitor *v)
{
  v->visitINoInit(this);
}

INoInit *INoInit::clone() const
{
  return new INoInit(*this);
}



/********************   IInit    ********************/
IInit::IInit(Ident p1, Expr *p2)
{
  ident_ = p1;
  expr_ = p2;

}

IInit::IInit(const IInit & other)
{
  ident_ = other.ident_;
  expr_ = other.expr_->clone();

}

IInit &IInit::operator=(const IInit & other)
{
  IInit tmp(other);
  swap(tmp);
  return *this;
}

void IInit::swap(IInit & other)
{
  std::swap(ident_, other.ident_);
  std::swap(expr_, other.expr_);

}

IInit::~IInit()
{
  delete(expr_);

}

void IInit::accept(Visitor *v)
{
  v->visitIInit(this);
}

IInit *IInit::clone() const
{
  return new IInit(*this);
}



/********************   TInt    ********************/
TInt::TInt()
{

}

TInt::TInt(const TInt & other)
{

}

TInt &TInt::operator=(const TInt & other)
{
  TInt tmp(other);
  swap(tmp);
  return *this;
}

void TInt::swap(TInt & other)
{

}

TInt::~TInt()
{

}

void TInt::accept(Visitor *v)
{
  v->visitTInt(this);
}

TInt *TInt::clone() const
{
  return new TInt(*this);
}



/********************   TStr    ********************/
TStr::TStr()
{

}

TStr::TStr(const TStr & other)
{

}

TStr &TStr::operator=(const TStr & other)
{
  TStr tmp(other);
  swap(tmp);
  return *this;
}

void TStr::swap(TStr & other)
{

}

TStr::~TStr()
{

}

void TStr::accept(Visitor *v)
{
  v->visitTStr(this);
}

TStr *TStr::clone() const
{
  return new TStr(*this);
}



/********************   TBool    ********************/
TBool::TBool()
{

}

TBool::TBool(const TBool & other)
{

}

TBool &TBool::operator=(const TBool & other)
{
  TBool tmp(other);
  swap(tmp);
  return *this;
}

void TBool::swap(TBool & other)
{

}

TBool::~TBool()
{

}

void TBool::accept(Visitor *v)
{
  v->visitTBool(this);
}

TBool *TBool::clone() const
{
  return new TBool(*this);
}



/********************   TVoid    ********************/
TVoid::TVoid()
{

}

TVoid::TVoid(const TVoid & other)
{

}

TVoid &TVoid::operator=(const TVoid & other)
{
  TVoid tmp(other);
  swap(tmp);
  return *this;
}

void TVoid::swap(TVoid & other)
{

}

TVoid::~TVoid()
{

}

void TVoid::accept(Visitor *v)
{
  v->visitTVoid(this);
}

TVoid *TVoid::clone() const
{
  return new TVoid(*this);
}



/********************   EVar    ********************/
EVar::EVar(Ident p1)
{
  ident_ = p1;

}

EVar::EVar(const EVar & other)
{
  ident_ = other.ident_;

}

EVar &EVar::operator=(const EVar & other)
{
  EVar tmp(other);
  swap(tmp);
  return *this;
}

void EVar::swap(EVar & other)
{
  std::swap(ident_, other.ident_);

}

EVar::~EVar()
{

}

void EVar::accept(Visitor *v)
{
  v->visitEVar(this);
}

EVar *EVar::clone() const
{
  return new EVar(*this);
}



/********************   ELitInt    ********************/
ELitInt::ELitInt(Integer p1)
{
  integer_ = p1;

}

ELitInt::ELitInt(const ELitInt & other)
{
  integer_ = other.integer_;

}

ELitInt &ELitInt::operator=(const ELitInt & other)
{
  ELitInt tmp(other);
  swap(tmp);
  return *this;
}

void ELitInt::swap(ELitInt & other)
{
  std::swap(integer_, other.integer_);

}

ELitInt::~ELitInt()
{

}

void ELitInt::accept(Visitor *v)
{
  v->visitELitInt(this);
}

ELitInt *ELitInt::clone() const
{
  return new ELitInt(*this);
}



/********************   ELitTrue    ********************/
ELitTrue::ELitTrue()
{

}

ELitTrue::ELitTrue(const ELitTrue & other)
{

}

ELitTrue &ELitTrue::operator=(const ELitTrue & other)
{
  ELitTrue tmp(other);
  swap(tmp);
  return *this;
}

void ELitTrue::swap(ELitTrue & other)
{

}

ELitTrue::~ELitTrue()
{

}

void ELitTrue::accept(Visitor *v)
{
  v->visitELitTrue(this);
}

ELitTrue *ELitTrue::clone() const
{
  return new ELitTrue(*this);
}



/********************   ELitFalse    ********************/
ELitFalse::ELitFalse()
{

}

ELitFalse::ELitFalse(const ELitFalse & other)
{

}

ELitFalse &ELitFalse::operator=(const ELitFalse & other)
{
  ELitFalse tmp(other);
  swap(tmp);
  return *this;
}

void ELitFalse::swap(ELitFalse & other)
{

}

ELitFalse::~ELitFalse()
{

}

void ELitFalse::accept(Visitor *v)
{
  v->visitELitFalse(this);
}

ELitFalse *ELitFalse::clone() const
{
  return new ELitFalse(*this);
}



/********************   EApp    ********************/
EApp::EApp(Ident p1, ListExpr *p2)
{
  ident_ = p1;
  listexpr_ = p2;

}

EApp::EApp(const EApp & other)
{
  ident_ = other.ident_;
  listexpr_ = other.listexpr_->clone();

}

EApp &EApp::operator=(const EApp & other)
{
  EApp tmp(other);
  swap(tmp);
  return *this;
}

void EApp::swap(EApp & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listexpr_, other.listexpr_);

}

EApp::~EApp()
{
  delete(listexpr_);

}

void EApp::accept(Visitor *v)
{
  v->visitEApp(this);
}

EApp *EApp::clone() const
{
  return new EApp(*this);
}



/********************   EString    ********************/
EString::EString(String p1)
{
  string_ = p1;

}

EString::EString(const EString & other)
{
  string_ = other.string_;

}

EString &EString::operator=(const EString & other)
{
  EString tmp(other);
  swap(tmp);
  return *this;
}

void EString::swap(EString & other)
{
  std::swap(string_, other.string_);

}

EString::~EString()
{

}

void EString::accept(Visitor *v)
{
  v->visitEString(this);
}

EString *EString::clone() const
{
  return new EString(*this);
}



/********************   ENeg    ********************/
ENeg::ENeg(Expr *p1)
{
  expr_ = p1;

}

ENeg::ENeg(const ENeg & other)
{
  expr_ = other.expr_->clone();

}

ENeg &ENeg::operator=(const ENeg & other)
{
  ENeg tmp(other);
  swap(tmp);
  return *this;
}

void ENeg::swap(ENeg & other)
{
  std::swap(expr_, other.expr_);

}

ENeg::~ENeg()
{
  delete(expr_);

}

void ENeg::accept(Visitor *v)
{
  v->visitENeg(this);
}

ENeg *ENeg::clone() const
{
  return new ENeg(*this);
}



/********************   ENot    ********************/
ENot::ENot(Expr *p1)
{
  expr_ = p1;

}

ENot::ENot(const ENot & other)
{
  expr_ = other.expr_->clone();

}

ENot &ENot::operator=(const ENot & other)
{
  ENot tmp(other);
  swap(tmp);
  return *this;
}

void ENot::swap(ENot & other)
{
  std::swap(expr_, other.expr_);

}

ENot::~ENot()
{
  delete(expr_);

}

void ENot::accept(Visitor *v)
{
  v->visitENot(this);
}

ENot *ENot::clone() const
{
  return new ENot(*this);
}



/********************   EMul    ********************/
EMul::EMul(Expr *p1, MulOp *p2, Expr *p3)
{
  expr_1 = p1;
  mulop_ = p2;
  expr_2 = p3;

}

EMul::EMul(const EMul & other)
{
  expr_1 = other.expr_1->clone();
  mulop_ = other.mulop_->clone();
  expr_2 = other.expr_2->clone();

}

EMul &EMul::operator=(const EMul & other)
{
  EMul tmp(other);
  swap(tmp);
  return *this;
}

void EMul::swap(EMul & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(mulop_, other.mulop_);
  std::swap(expr_2, other.expr_2);

}

EMul::~EMul()
{
  delete(expr_1);
  delete(mulop_);
  delete(expr_2);

}

void EMul::accept(Visitor *v)
{
  v->visitEMul(this);
}

EMul *EMul::clone() const
{
  return new EMul(*this);
}



/********************   EAdd    ********************/
EAdd::EAdd(Expr *p1, AddOp *p2, Expr *p3)
{
  expr_1 = p1;
  addop_ = p2;
  expr_2 = p3;

}

EAdd::EAdd(const EAdd & other)
{
  expr_1 = other.expr_1->clone();
  addop_ = other.addop_->clone();
  expr_2 = other.expr_2->clone();

}

EAdd &EAdd::operator=(const EAdd & other)
{
  EAdd tmp(other);
  swap(tmp);
  return *this;
}

void EAdd::swap(EAdd & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(addop_, other.addop_);
  std::swap(expr_2, other.expr_2);

}

EAdd::~EAdd()
{
  delete(expr_1);
  delete(addop_);
  delete(expr_2);

}

void EAdd::accept(Visitor *v)
{
  v->visitEAdd(this);
}

EAdd *EAdd::clone() const
{
  return new EAdd(*this);
}



/********************   ERel    ********************/
ERel::ERel(Expr *p1, RelOp *p2, Expr *p3)
{
  expr_1 = p1;
  relop_ = p2;
  expr_2 = p3;

}

ERel::ERel(const ERel & other)
{
  expr_1 = other.expr_1->clone();
  relop_ = other.relop_->clone();
  expr_2 = other.expr_2->clone();

}

ERel &ERel::operator=(const ERel & other)
{
  ERel tmp(other);
  swap(tmp);
  return *this;
}

void ERel::swap(ERel & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(relop_, other.relop_);
  std::swap(expr_2, other.expr_2);

}

ERel::~ERel()
{
  delete(expr_1);
  delete(relop_);
  delete(expr_2);

}

void ERel::accept(Visitor *v)
{
  v->visitERel(this);
}

ERel *ERel::clone() const
{
  return new ERel(*this);
}



/********************   EAnd    ********************/
EAnd::EAnd(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EAnd::EAnd(const EAnd & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EAnd &EAnd::operator=(const EAnd & other)
{
  EAnd tmp(other);
  swap(tmp);
  return *this;
}

void EAnd::swap(EAnd & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EAnd::~EAnd()
{
  delete(expr_1);
  delete(expr_2);

}

void EAnd::accept(Visitor *v)
{
  v->visitEAnd(this);
}

EAnd *EAnd::clone() const
{
  return new EAnd(*this);
}



/********************   EOr    ********************/
EOr::EOr(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EOr::EOr(const EOr & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EOr &EOr::operator=(const EOr & other)
{
  EOr tmp(other);
  swap(tmp);
  return *this;
}

void EOr::swap(EOr & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EOr::~EOr()
{
  delete(expr_1);
  delete(expr_2);

}

void EOr::accept(Visitor *v)
{
  v->visitEOr(this);
}

EOr *EOr::clone() const
{
  return new EOr(*this);
}



/********************   OPlus    ********************/
OPlus::OPlus()
{

}

OPlus::OPlus(const OPlus & other)
{

}

OPlus &OPlus::operator=(const OPlus & other)
{
  OPlus tmp(other);
  swap(tmp);
  return *this;
}

void OPlus::swap(OPlus & other)
{

}

OPlus::~OPlus()
{

}

void OPlus::accept(Visitor *v)
{
  v->visitOPlus(this);
}

OPlus *OPlus::clone() const
{
  return new OPlus(*this);
}



/********************   OMinus    ********************/
OMinus::OMinus()
{

}

OMinus::OMinus(const OMinus & other)
{

}

OMinus &OMinus::operator=(const OMinus & other)
{
  OMinus tmp(other);
  swap(tmp);
  return *this;
}

void OMinus::swap(OMinus & other)
{

}

OMinus::~OMinus()
{

}

void OMinus::accept(Visitor *v)
{
  v->visitOMinus(this);
}

OMinus *OMinus::clone() const
{
  return new OMinus(*this);
}



/********************   OTimes    ********************/
OTimes::OTimes()
{

}

OTimes::OTimes(const OTimes & other)
{

}

OTimes &OTimes::operator=(const OTimes & other)
{
  OTimes tmp(other);
  swap(tmp);
  return *this;
}

void OTimes::swap(OTimes & other)
{

}

OTimes::~OTimes()
{

}

void OTimes::accept(Visitor *v)
{
  v->visitOTimes(this);
}

OTimes *OTimes::clone() const
{
  return new OTimes(*this);
}



/********************   ODiv    ********************/
ODiv::ODiv()
{

}

ODiv::ODiv(const ODiv & other)
{

}

ODiv &ODiv::operator=(const ODiv & other)
{
  ODiv tmp(other);
  swap(tmp);
  return *this;
}

void ODiv::swap(ODiv & other)
{

}

ODiv::~ODiv()
{

}

void ODiv::accept(Visitor *v)
{
  v->visitODiv(this);
}

ODiv *ODiv::clone() const
{
  return new ODiv(*this);
}



/********************   OMod    ********************/
OMod::OMod()
{

}

OMod::OMod(const OMod & other)
{

}

OMod &OMod::operator=(const OMod & other)
{
  OMod tmp(other);
  swap(tmp);
  return *this;
}

void OMod::swap(OMod & other)
{

}

OMod::~OMod()
{

}

void OMod::accept(Visitor *v)
{
  v->visitOMod(this);
}

OMod *OMod::clone() const
{
  return new OMod(*this);
}



/********************   OLTH    ********************/
OLTH::OLTH()
{

}

OLTH::OLTH(const OLTH & other)
{

}

OLTH &OLTH::operator=(const OLTH & other)
{
  OLTH tmp(other);
  swap(tmp);
  return *this;
}

void OLTH::swap(OLTH & other)
{

}

OLTH::~OLTH()
{

}

void OLTH::accept(Visitor *v)
{
  v->visitOLTH(this);
}

OLTH *OLTH::clone() const
{
  return new OLTH(*this);
}



/********************   OLE    ********************/
OLE::OLE()
{

}

OLE::OLE(const OLE & other)
{

}

OLE &OLE::operator=(const OLE & other)
{
  OLE tmp(other);
  swap(tmp);
  return *this;
}

void OLE::swap(OLE & other)
{

}

OLE::~OLE()
{

}

void OLE::accept(Visitor *v)
{
  v->visitOLE(this);
}

OLE *OLE::clone() const
{
  return new OLE(*this);
}



/********************   OGTH    ********************/
OGTH::OGTH()
{

}

OGTH::OGTH(const OGTH & other)
{

}

OGTH &OGTH::operator=(const OGTH & other)
{
  OGTH tmp(other);
  swap(tmp);
  return *this;
}

void OGTH::swap(OGTH & other)
{

}

OGTH::~OGTH()
{

}

void OGTH::accept(Visitor *v)
{
  v->visitOGTH(this);
}

OGTH *OGTH::clone() const
{
  return new OGTH(*this);
}



/********************   OGE    ********************/
OGE::OGE()
{

}

OGE::OGE(const OGE & other)
{

}

OGE &OGE::operator=(const OGE & other)
{
  OGE tmp(other);
  swap(tmp);
  return *this;
}

void OGE::swap(OGE & other)
{

}

OGE::~OGE()
{

}

void OGE::accept(Visitor *v)
{
  v->visitOGE(this);
}

OGE *OGE::clone() const
{
  return new OGE(*this);
}



/********************   OEQU    ********************/
OEQU::OEQU()
{

}

OEQU::OEQU(const OEQU & other)
{

}

OEQU &OEQU::operator=(const OEQU & other)
{
  OEQU tmp(other);
  swap(tmp);
  return *this;
}

void OEQU::swap(OEQU & other)
{

}

OEQU::~OEQU()
{

}

void OEQU::accept(Visitor *v)
{
  v->visitOEQU(this);
}

OEQU *OEQU::clone() const
{
  return new OEQU(*this);
}



/********************   ONE    ********************/
ONE::ONE()
{

}

ONE::ONE(const ONE & other)
{

}

ONE &ONE::operator=(const ONE & other)
{
  ONE tmp(other);
  swap(tmp);
  return *this;
}

void ONE::swap(ONE & other)
{

}

ONE::~ONE()
{

}

void ONE::accept(Visitor *v)
{
  v->visitONE(this);
}

ONE *ONE::clone() const
{
  return new ONE(*this);
}




/********************   ListTopDef    ********************/

void ListTopDef::accept(Visitor *v)
{
  v->visitListTopDef(this);
}


ListTopDef *ListTopDef::clone() const
{
  return new ListTopDef(*this);
}


/********************   ListArg    ********************/

void ListArg::accept(Visitor *v)
{
  v->visitListArg(this);
}


ListArg *ListArg::clone() const
{
  return new ListArg(*this);
}


/********************   ListStmt    ********************/

void ListStmt::accept(Visitor *v)
{
  v->visitListStmt(this);
}


ListStmt *ListStmt::clone() const
{
  return new ListStmt(*this);
}


/********************   ListItem    ********************/

void ListItem::accept(Visitor *v)
{
  v->visitListItem(this);
}


ListItem *ListItem::clone() const
{
  return new ListItem(*this);
}


/********************   ListExpr    ********************/

void ListExpr::accept(Visitor *v)
{
  v->visitListExpr(this);
}


ListExpr *ListExpr::clone() const
{
  return new ListExpr(*this);
}



}
